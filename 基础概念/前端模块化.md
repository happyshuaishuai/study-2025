## 前端模块化简述

前端模块化是一种将代码按照功能拆分为独立模块的开发方式，每个模块负责单一功能，互不干扰。模块化有助于提升代码的可维护性、可复用性和协作效率。常见的模块化规范有: 

1. CommonJS
主要用于 Node.js 环境，通过 require 导入模块，module.exports 导出模块。

每个文件就是一个模块，有自己的作用域。
在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。
加载某个模块，其实是加载该模块的module.exports属性。
require命令用于加载模块文件。
require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。

以下是一个简单的 CommonJS 模块化的示例：

```javascript
// math.js
module.exports.add = function(a, b) {
  return a + b;
};

// main.js
const math = require('./math');
console.log(math.add(2, 3)); // 输出 5
```
2. AMD
主要用于浏览器端，异步加载模块，常用库如 RequireJS。
如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。
RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载。
AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系。
```javascript
// math.js
// 定义没有依赖的模块
define([], function() {
    return 模块
});
// 定义有依赖的模块
define(['module1','module2'], function() {
    return 模块
});

define([], function() {
  return {
    add: function(a, b) {
      return a + b;
    }
  };
});

// main.js
require(['math'], function(math) {
  console.log(math.add(2, 3)); // 输出 5
});
```

3. CMD  
主要由 SeaJS 推广。
CMD 规范强调依赖就近，按需加载，模块的依赖可以写在需要时再 require。与 AMD 不同，CMD 更灵活，适合复杂依赖场景。

CMD 的基本用法如下：

```javascript
// math.js
define(function(require, exports, module) {
    exports.add = function(a, b) {
        return a + b;
    };
});

// main.js
define(function(require) {
    var math = require('./math');
    console.log(math.add(2, 3)); // 输出 5
});
```

CMD 规范的特点：
- 依赖可以写在模块内部，按需加载。
- 支持异步加载，适合浏览器环境。
- 语法简洁，易于上手。
- 主要应用于 SeaJS 等模块加载器。

4. ES6模块化  
ES6（ECMAScript 2015）原生支持模块化，采用 `import` 和 `export` 关键字进行模块的导入和导出。ES6模块在编译时就确定依赖关系，支持静态分析，能够实现更高效的打包和优化。

CommonJS 和 AMD 模块，都只能在运行时确定依赖关系。

ES6模块的特点：
- 语法简洁，易于理解和使用。
- 支持静态分析，有利于工具优化（如 Tree Shaking）。
- 默认采用严格模式。
- 支持异步和动态导入（`import()`）。

基本用法示例：

```javascript
// math.js
export function add(a, b) {
    return a + b;
}

// main.js
import { add } from './math.js';
console.log(add(2, 3)); // 输出 5
```


ES6模块化已成为现代前端开发的主流方案，被广泛应用于各类前端框架和项目中。

ES6 模块与 CommonJS 模块的差异

CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。


CommonJS 示例

```javascript
let counter = 1;
function increment() {
  counter++;
}
module.exports = { counter, increment };

const moduleA = require('./moduleA');
console.log(moduleA.counter); // 输出 1
moduleA.increment();
console.log(moduleA.counter); // 还是输出 1（拷贝，不会变）
```

ES6 模块示例

```javascript
export let counter = 1;
export function increment() {
  counter++;
}
import { counter, increment } from './moduleA.mjs';
console.log(counter); // 输出 1
increment();
console.log(counter); // 输出 2（引用，值会变）
```

CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
